import pandas as pdimport numpy as npfrom sklearn.decomposition import TruncatedSVDclass OASImputer:    def __init__(self, n_factors=10):        """        n_factors : nombre de 'facteurs latents' (les thèmes cachés du marché).        Plus il y a d'obligations, plus on peut augmenter ce chiffre.        """        self.n_factors = n_factors        # On utilise TruncatedSVD qui est la version "Recommender System" de l'PCA        self.svd = TruncatedSVD(n_components=n_factors, random_state=42)    def naive_fill(self, df_incomplete):        """        MÉTHODE 1 : Basique (Baseline)        On remplit les trous par la dernière valeur connue (Forward Fill).        """        # ffill(axis=1) : propage la dernière valeur connue vers la droite (le futur)        # bfill(axis=1) : si le début est vide, propage la première valeur vers la gauche        return df_incomplete.ffill(axis=1).bfill(axis=1)    def matrix_factorization_fill(self, df_incomplete, iterations=3):        mask_missing = df_incomplete.isnull()        row_means = df_incomplete.mean(axis=1)                # Initialisation : on commence par un remplissage naïf pour avoir une base propre        curr_filled = df_incomplete.ffill(axis=1).bfill(axis=1)                for _ in range(iterations):            # Centrer            df_centered = curr_filled.sub(row_means, axis=0)                        # SVD            latent = self.svd.fit_transform(df_centered)            reconstructed = np.dot(latent, self.svd.components_)                        # Re-transformer en DataFrame            df_rec = pd.DataFrame(reconstructed, index=df_incomplete.index, columns=df_incomplete.columns)            df_rec = df_rec.add(row_means, axis=0)                        # Mise à jour : on ne remplace QUE les trous            curr_filled[mask_missing] = df_rec[mask_missing]                    return curr_filled