import numpy as npimport pandas as pdimport yamlimport osclass BondDataGenerator:    def __init__(self, config_path):        # Charger la configuration        with open(config_path, 'r') as f:            self.config = yaml.safe_load(f)                def generate(self):        conf = self.config['simulation']        mkt = self.config['market']                dates = pd.date_range(start=conf['start_date'], periods=conf['n_days'])        bond_ids = [f"BOND_{i:03d}" for i in range(conf['n_bonds'])]                # 1. Créer les métadonnées (Secteur et Rating pour chaque obligation)        metadata = pd.DataFrame({            'bond_id': bond_ids,            'sector': np.random.choice(mkt['sectors'], conf['n_bonds']),            'rating': np.random.choice(mkt['ratings'], conf['n_bonds'])        }).set_index('bond_id')        # 2. Simuler les facteurs de marché (Marche aléatoire pour le spread global)        # On simule un mouvement de marché qui affecte tout le monde        market_trend = np.cumsum(np.random.normal(0, 2, conf['n_days']))                # 3. Simuler les spreads OAS        sp_data = np.zeros((conf['n_bonds'], conf['n_days']))                # On génère un mouvement spécifique pour chaque secteur        sector_trends = {s: np.cumsum(np.random.normal(0, 1.5, conf['n_days'])) for s in mkt['sectors']}        for i, b_id in enumerate(bond_ids):            sector = metadata.loc[b_id, 'sector']            # Chaque obligation a une sensibilité propre au marché            beta = np.random.uniform(0.7, 1.3)            idiosyncratic_noise = np.random.normal(0, 5, conf['n_days'])            # Formule : Spread = Base + Tendance_Marché + Bruit_Secteur + Bruit_Spécifique            sp_data[i, :] = (mkt['base_spread'] +                              beta * market_trend +                              sector_trends[sector] +                              idiosyncratic_noise)        df_full = pd.DataFrame(sp_data, index=bond_ids, columns=dates)        return df_full, metadata    def apply_illiquidity(self, df):        """Introduit des NaN selon le taux défini dans la config"""        rate = self.config['illiquidity']['missing_rate']        df_incomplete = df.copy()        mask = np.random.rand(*df.shape) < rate        df_incomplete[mask] = np.nan        return df_incompleteif __name__ == "__main__":    # 1. On récupère le chemin absolu du dossier où se trouve ce script (src/)    script_dir = os.path.dirname(os.path.abspath(__file__))    # 2. On remonte d'un niveau pour arriver à la racine du projet    project_root = os.path.dirname(script_dir)    # 3. On construit le chemin vers le fichier de config    config_path = os.path.join(project_root, 'config', 'settings.yaml')        gen = BondDataGenerator(config_path)    full, meta = gen.generate()    incomplete = gen.apply_illiquidity(full)        print(f"Génération réussie : {full.shape[0]} obligations sur {full.shape[1]} jours.")    print(f"Taux de données manquantes : {incomplete.isnull().sum().sum() / incomplete.size:.2%}")   